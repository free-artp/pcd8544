#ifndef LCD_PCD8544

#define LCD_PCD8544


// -------------------------------------------------------------------------------------------------------------------
// ВЫБОР ИНТЕРФЕЙСА УПРАВЛЕНИЯ ДИСПЛЕЕМ
// -------------------------------------------------------------------------------------------------------------------
// если следующее определение закомментировано то работает програмный SPI
// если раскомментировано - то аппаратный SPI2
// по скорости у меня получилось что аппаратный SPI в 5 раза быстрее заполнял экран (SPI2 = 18 мс, против SOFT-SPI=97 мс)
#define LCD_TO_SPI2

// -------------------------------------------------------------------------------------------------------------------
// ИСПОЛЬЗОВАНИЕ DMA ПРИ ОБМЕНЕ С ДИСПЛЕЕМ
// -------------------------------------------------------------------------------------------------------------------
//#define LCD_SPI2_DMA


// -------------------------------------------------------------------------------------------------------------------
// СКОРОСТЬ ПРОВЕДЕНИЯ ИНИЦИАЛИЗАЦИИ
// -------------------------------------------------------------------------------------------------------------------
//                   +---+
#define LCD_RST_DLY    2		// пауза в мс при сбросе дисплея
//                   +---+      если дисплей не запускается или запускается через раз - увеличивайте значение


// -------------------------------------------------------------------------------------------------------------------
// СКОРОСТЬ ПЕРЕДАЧИ ДАННЫХ НА ДИСПЛЕЙ
// -------------------------------------------------------------------------------------------------------------------
// Если используется аппаратный SPI2 то следующая настройка определяет скорость передачи данных на дисплей
// частота которая будет подана на блок SPI будет определена исходя из формулы  sysclk / (AHB_Presc * ABP1_Presc)
// потом при передаче данных эта частота будет поделена на еще один делитель который нужно определить ниже
// например для STM32F4 на частоте 168 мгц частота подаваемая на блок SPI2 = 168 мгц / 1 * 4 = 42 мгц
// после делителя SPI2 = 2 частота передачи информации составит 42 / 2 = 21 мгц

// допустимые значения делителя:
//                               SPI_BaudRatePrescaler_2
//                               SPI_BaudRatePrescaler_4
//                               SPI_BaudRatePrescaler_8
//                               SPI_BaudRatePrescaler_16
//                               SPI_BaudRatePrescaler_32
// при больших значениях делителя (>32) частота становиться слишком низкой и работа дисплея не гарантируется !

// ЕСЛИ ВЫ ТОЛЬКО ПРОБУЕТЕ ПОДКЛЮЧИТЬ ДИСПЛЕЙ ПОСТАВЬТЕ ЗНАЧЕНИЕ "SPI_BaudRatePrescaler_8"
//                              +-----------------------+
#define SPI2_BaudRatePrescaler   SPI_BaudRatePrescaler_8		// делитель SPI2
//                              +-----------------------+



// -----------------------------------------------------------------------------------------------------------------
// РУЧНОЕ УПРАВЛЕНИЕ ВЫБОРОМ ДИСПЛЕЯ
// -----------------------------------------------------------------------------------------------------------------
// если параметр ниже закомментирован то устанавливать линию выбора дисплея нужно в коде основной программы
// вызовами:
// LCD_CS0; - для выбора дисплея перед началом проведения операций (нескольких) с дисплеем
// LCD_CS1; - для отмены выбора дисплея (после совершения операций)
// если параметр активен - то выбор дисплея осуществляется автоматически по мере необходимости
#define LCD_SEL_AUTO



// ---------------------------------------------------------------------------------------------------------------------------
// ЭЛЕКТРИЧЕСКОЕ ПОДКЛЮЧЕНИЕ ДИСПЛЕЯ
// ---------------------------------------------------------------------------------------------------------------------------
// для простоты драйвера при программном SPI все линии управления и данных дисплея должны быть подключены к одному порту ввода\вывода !
// если же задан режим аппаратного SPI2 то, на один порт должны быть подключены линии RST, A0, CSE
// а остальные линии (SDA, SCK) должны быть подключены к GPIOB (пины 15 и 13 соответственно)
//                             +--------------------+
#define 	LCD_GPIO			GPIOB					// порт к которому подключены пины дисплея
//                             +--------------------+
#define     LCD_AHB1_GPIO		RCC_AHB1Periph_GPIOB	// шина к которой подключен порт
//                             +--------------------+
// пины дисплея (управление)
//                             +--+
#define 	LCD_RST_PIN 		14
//                             +--+
#define     LCD_A0_PIN			12
//                             +--+
#define		LCD_CSE_PIN			10
//                             +--+
//
// в случае если используется SPI2 подключение то вывод SDA дисплея должен быть подключен к GPIOB_Pin_15, и SCK к GPIOB_Pin_13
// остальные линии при SPI2 подключении могут быть подключены к любому порту (не только к GPIOB) см. выше
// пины дисплея (данные)
//                             +--+
#define		LCD_SDA_PIN			15
//                             +--+
#define		LCD_SCK_PIN			13
//                             +--+



// ------------------------------------------------------------------------------------------------------------------------------
//                                      ДАЛЬШЕ   НАСТРАИВАЕМЫХ   ПАРАМЕТРОВ   НЕТ   !!!
// ------------------------------------------------------------------------------------------------------------------------------
// определения для битбанда
#define IO_BB_ADDR(io_reg_addr,bit_number) ((uint32_t*)(PERIPH_BB_BASE + (((uint32_t)io_reg_addr - PERIPH_BASE) << 5) + (bit_number << 2)))

#define LCD_RST_BB_ADDR  IO_BB_ADDR(&LCD_GPIO->ODR, LCD_RST_PIN)
#define LCD_A0_BB_ADDR   IO_BB_ADDR(&LCD_GPIO->ODR, LCD_A0_PIN)
#define LCD_CSE_BB_ADDR  IO_BB_ADDR(&LCD_GPIO->ODR, LCD_CSE_PIN)
#define LCD_SDA_BB_ADDR  IO_BB_ADDR(&LCD_GPIO->ODR, LCD_SDA_PIN)
#define LCD_SCK_BB_ADDR  IO_BB_ADDR(&LCD_GPIO->ODR, LCD_SCK_PIN)

// Управление линией LCD_RST
#define LCD_RST1  *LCD_RST_BB_ADDR=0x00000001
#define LCD_RST0  *LCD_RST_BB_ADDR=0x00000000
// Управление линией LCD_DC
#define LCD_DC1   *LCD_A0_BB_ADDR=0x00000001
#define LCD_DC0   *LCD_A0_BB_ADDR=0x00000000
// Управление линией LCD_CS
#define LCD_CS1   *LCD_CSE_BB_ADDR=0x00000001
#define LCD_CS0   *LCD_CSE_BB_ADDR=0x00000000

#ifndef LCD_TO_SPI2
// Управление линией LCD_SCK
#define LCD_SCK1  *LCD_SCK_BB_ADDR=0x00000001
#define LCD_SCK0  *LCD_SCK_BB_ADDR=0x00000000
// Управление линией LCD_MOSI
#define LCD_MOSI1 *LCD_SDA_BB_ADDR=0x00000001
#define LCD_MOSI0 *LCD_SDA_BB_ADDR=0x00000000
#endif


// ---------------------------------------------------------------------------------------------------------------------------------
// процедуры управления и вывода
//
void lcd8544_init(void); // инициализация дисплея
		// отправка команды на дисплей
void lcd8544_sendCmd(unsigned char cmd);
		// очистка дисплея
void lcd8544_refresh(void);
		// очистка буфера
void lcd8544_clear(void);
		// вывод пиксела
void lcd8544_putpix(unsigned char x, unsigned char y, unsigned char mode);
		// вывод линии
void lcd8544_line(unsigned char x1, unsigned char y1, unsigned char x2, unsigned char y2, unsigned char mode);
		// рисование прямоугольника (не заполненного)
void lcd8544_rect(unsigned char x1, unsigned char y1, unsigned char x2, unsigned char y2, unsigned char mode);
		// вывод символа в цвете по координатам
void lcd8544_putchar(unsigned char px, unsigned char py, unsigned char ch, unsigned char mode);
		// линия левее символа для печати в инверсе
void lcd8544_leftchline(unsigned char x, unsigned char y);
		// вывод строки в цвете по координатам
void lcd8544_putstr(unsigned char x, unsigned char y, const unsigned char str[], unsigned char mode);
		// печать десятичного числа
void lcd8544_dec(unsigned int numb, unsigned char dcount, unsigned char x, unsigned char y, unsigned char mode);

void lcd8544_shift_left(unsigned char dx);

#endif

